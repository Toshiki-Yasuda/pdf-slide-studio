<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>PDF Slide Studio Pro v7.2</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
  <style>
    *{-webkit-tap-highlight-color:transparent}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif}
    @keyframes aurora-1{0%,100%{transform:translate(0,0)}50%{transform:translate(20px,-20px)}}
    @keyframes aurora-2{0%,100%{transform:translate(0,0)}50%{transform:translate(-20px,10px)}}
    .animate-aurora-1{animation:aurora-1 10s infinite}
    .animate-aurora-2{animation:aurora-2 12s infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .animate-spin{animation:spin 1s linear infinite}
    .touch-feedback:active{transform:scale(0.98);opacity:0.9}
    .custom-scrollbar::-webkit-scrollbar{width:6px}
    .custom-scrollbar::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.2);border-radius:3px}
    .progress-ring{transform:rotate(-90deg)}
    button:disabled{opacity:0.5;cursor:not-allowed}
    .tab-active{background:rgba(6,182,212,0.2);border-color:rgb(6,182,212);color:rgb(6,182,212)}
  </style>
</head>
<body class="bg-slate-950 text-slate-200 min-h-screen">
  <div class="fixed inset-0 pointer-events-none overflow-hidden">
    <div class="absolute top-[-10%] left-[-10%] w-[50%] h-[50%] bg-indigo-600/20 rounded-full blur-[100px] animate-aurora-1"></div>
    <div class="absolute bottom-[-10%] right-[-10%] w-[50%] h-[50%] bg-cyan-600/20 rounded-full blur-[100px] animate-aurora-2"></div>
  </div>
  <div id="app" class="relative z-10 min-h-screen p-4 md:p-6">
    <div class="w-full max-w-7xl mx-auto space-y-5">
      <header class="text-center space-y-2 pt-2">
        <div class="inline-flex items-center gap-2 px-3 py-1.5 rounded-full bg-gradient-to-r from-cyan-500/20 to-indigo-500/20 border border-white/10">
          <i data-lucide="sparkles" class="w-3.5 h-3.5 text-cyan-300"></i>
          <span class="text-[10px] uppercase tracking-widest font-bold text-cyan-300">PDF Slide Studio Pro v7.2</span>
        </div>
        <div id="header-content">
          <h1 class="text-2xl md:text-3xl font-extrabold text-white">AIç´šã‚¤ãƒ³ãƒšã‚¤ãƒ³ãƒ†ã‚£ãƒ³ã‚°</h1>
          <p class="text-slate-400 text-sm max-w-xl mx-auto mt-2">ãƒãƒ«ãƒãƒ‘ã‚¹èƒŒæ™¯è£œå®Œãƒ»ç ´ææ–‡å­—ä¿®å¾©ãƒ»é«˜ç²¾åº¦æ¤œå‡º</p>
        </div>
      </header>
      <main id="main-content">
        <div id="upload-area" class="bg-white/5 backdrop-blur-2xl rounded-2xl border border-white/10 overflow-hidden">
          <input type="file" id="file-input" class="hidden" accept="application/pdf,.pdf">
          <button type="button" id="upload-button" class="w-full p-6 md:p-8 text-center cursor-pointer group hover:bg-white/5 transition-all touch-feedback">
            <div class="flex flex-col items-center gap-4">
              <div class="w-16 h-16 rounded-2xl flex items-center justify-center bg-gradient-to-br from-cyan-500/20 to-indigo-500/20 text-cyan-300 group-hover:scale-110 transition-transform"><i data-lucide="layers" class="w-8 h-8"></i></div>
              <div><p class="text-lg font-bold text-slate-200">PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</p><p class="text-xs text-slate-500 mt-1">ã‚¿ãƒƒãƒ—ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</p></div>
              <div class="flex flex-wrap justify-center gap-2 mt-2">
                <span class="px-2 py-1 bg-green-500/20 text-green-300 text-[10px] rounded-full">âœ¨ ãƒãƒ«ãƒãƒ‘ã‚¹</span>
                <span class="px-2 py-1 bg-blue-500/20 text-blue-300 text-[10px] rounded-full">ğŸ”§ æ–‡å­—ä¿®å¾©</span>
                <span class="px-2 py-1 bg-purple-500/20 text-purple-300 text-[10px] rounded-full">ğŸ“ é«˜ç²¾åº¦</span>
              </div>
              <div class="w-full max-w-2xl mt-4 grid grid-cols-1 md:grid-cols-3 gap-3">
                <fieldset class="p-3 bg-slate-900/50 rounded-xl border border-slate-700/50">
                  <legend class="text-xs font-bold text-slate-300 mb-2"><i data-lucide="scan-text" class="w-3 h-3 inline"></i> OCR</legend>
                  <select id="ocr-language" class="w-full bg-slate-800/50 border border-slate-700 rounded-lg px-2 py-1.5 text-xs text-slate-300 mb-2">
                    <option value="jpn+eng">æ—¥æœ¬èª+è‹±èª</option><option value="jpn">æ—¥æœ¬èª</option><option value="eng">è‹±èª</option>
                  </select>
                  <label class="flex items-center justify-between"><span class="text-xs text-slate-400">ä¿¡é ¼åº¦</span><div class="flex items-center gap-1"><input type="range" id="min-confidence" min="20" max="80" value="40" class="w-12 h-1.5 accent-cyan-500"><span id="min-confidence-value" class="text-xs text-slate-300 w-7">40%</span></div></label>
                </fieldset>
                <fieldset class="p-3 bg-slate-900/50 rounded-xl border border-slate-700/50">
                  <legend class="text-xs font-bold text-slate-300 mb-2"><i data-lucide="wand-2" class="w-3 h-3 inline"></i> ã‚¤ãƒ³ãƒšã‚¤ãƒ³ãƒˆ</legend>
                  <label class="flex items-center justify-between mb-2"><span class="text-xs text-slate-400">å¼·åº¦</span><div class="flex items-center gap-1"><input type="range" id="inpaint-strength" min="2" max="15" value="8" class="w-12 h-1.5 accent-cyan-500"><span id="inpaint-strength-value" class="text-xs text-slate-300 w-5">8</span></div></label>
                  <label class="flex items-center justify-between mb-2"><span class="text-xs text-slate-400">ãƒ–ãƒ¬ãƒ³ãƒ‰</span><div class="flex items-center gap-1"><input type="range" id="blend-radius" min="4" max="24" value="12" class="w-12 h-1.5 accent-cyan-500"><span id="blend-radius-value" class="text-xs text-slate-300 w-5">12</span></div></label>
                  <label class="flex items-center gap-1.5"><input type="checkbox" id="multi-pass" checked class="w-3.5 h-3.5 rounded text-cyan-500"><span class="text-xs text-slate-400">ãƒãƒ«ãƒãƒ‘ã‚¹(3å›)</span></label>
                </fieldset>
                <fieldset class="p-3 bg-slate-900/50 rounded-xl border border-slate-700/50">
                  <legend class="text-xs font-bold text-slate-300 mb-2"><i data-lucide="shield" class="w-3 h-3 inline"></i> ä¿è­·</legend>
                  <label class="flex items-center justify-between mb-2"><span class="text-xs text-slate-400">å›³å½¢ä¿è­·</span><div class="flex items-center gap-1"><input type="range" id="shape-protection" min="30" max="100" value="60" class="w-12 h-1.5 accent-cyan-500"><span id="shape-protection-value" class="text-xs text-slate-300 w-7">60%</span></div></label>
                  <label class="flex items-center gap-1.5 mb-1"><input type="checkbox" id="detect-graphics" checked class="w-3.5 h-3.5 rounded text-cyan-500"><span class="text-xs text-slate-400">å›³å½¢æ¤œå‡º</span></label>
                  <label class="flex items-center gap-1.5"><input type="checkbox" id="fix-broken-text" checked class="w-3.5 h-3.5 rounded text-cyan-500"><span class="text-xs text-slate-400">ç ´ææ–‡å­—ä¿®å¾©</span></label>
                </fieldset>
              </div>
              <details class="w-full max-w-2xl mt-2"><summary class="text-xs text-slate-500 cursor-pointer hover:text-slate-300">è©³ç´°è¨­å®š</summary>
                <div class="mt-3 grid grid-cols-2 gap-3">
                  <fieldset class="p-3 bg-slate-900/50 rounded-xl border border-slate-700/50">
                    <legend class="text-xs font-bold text-slate-300 mb-2">ãƒ•ã‚©ãƒ³ãƒˆ</legend>
                    <select id="font-family" class="w-full bg-slate-800/50 border border-slate-700 rounded px-2 py-1.5 text-xs text-slate-300 mb-2"><option value="Meiryo">ãƒ¡ã‚¤ãƒªã‚ª</option><option value="Yu Gothic">æ¸¸ã‚´ã‚·ãƒƒã‚¯</option><option value="Noto Sans JP">Noto Sans</option></select>
                    <label class="flex items-center gap-1.5"><input type="checkbox" id="auto-bold" checked class="w-3.5 h-3.5 rounded text-cyan-500"><span class="text-xs text-slate-400">å¤§æ–‡å­—å¤ªå­—</span></label>
                    <label class="flex items-center gap-1.5 mt-1"><input type="checkbox" id="detect-text-color" checked class="w-3.5 h-3.5 rounded text-cyan-500"><span class="text-xs text-slate-400">è‰²æ¤œå‡º</span></label>
                  </fieldset>
                  <fieldset class="p-3 bg-slate-900/50 rounded-xl border border-slate-700/50">
                    <legend class="text-xs font-bold text-slate-300 mb-2">å“è³ª</legend>
                    <select id="quality-mode" class="w-full bg-slate-800/50 border border-slate-700 rounded px-2 py-1.5 text-xs text-slate-300 mb-2"><option value="fast">é«˜é€Ÿ</option><option value="balanced" selected>ãƒãƒ©ãƒ³ã‚¹</option><option value="quality">é«˜å“è³ª</option></select>
                    <label class="flex items-center gap-1.5"><input type="checkbox" id="smooth-edges" checked class="w-3.5 h-3.5 rounded text-cyan-500"><span class="text-xs text-slate-400">ã‚¨ãƒƒã‚¸å¹³æ»‘åŒ–</span></label>
                  </fieldset>
                </div>
              </details>
              <div class="mt-4 px-6 py-3 bg-gradient-to-r from-cyan-600 to-indigo-600 hover:from-cyan-700 hover:to-indigo-700 text-white rounded-xl font-medium text-sm transition-all shadow-lg flex items-center gap-2"><i data-lucide="upload" class="w-4 h-4"></i>å¤‰æ›é–‹å§‹</div>
              <div id="init-status" class="inline-flex items-center gap-2 px-3 py-1 bg-black/20 text-slate-400 text-xs rounded-full"><i data-lucide="loader-2" class="w-3 h-3 animate-spin text-cyan-400"></i><span>æº–å‚™ä¸­...</span></div>
            </div>
          </button>
        </div>
        <div id="processing-area" class="hidden bg-white/5 backdrop-blur-2xl rounded-2xl border border-white/10 p-10 flex-col items-center justify-center min-h-[320px]">
          <div class="relative w-28 h-28 mb-5">
            <svg class="w-full h-full progress-ring" viewBox="0 0 100 100"><circle class="text-slate-800/50 stroke-current" stroke-width="3" cx="50" cy="50" r="46" fill="transparent"></circle><circle id="progress-circle" class="text-cyan-400 stroke-current" stroke-width="3" stroke-linecap="round" cx="50" cy="50" r="46" fill="transparent" stroke-dasharray="0 289" style="filter:drop-shadow(0 0 6px rgba(34,211,238,0.8))"></circle></svg>
            <div class="absolute inset-0 flex flex-col items-center justify-center"><span id="progress-percent" class="text-xl font-bold text-white">0%</span></div>
          </div>
          <h3 id="progress-message" class="text-base font-bold text-white mb-1">å‡¦ç†ä¸­...</h3>
          <p id="progress-detail" class="text-sm text-slate-400"></p>
          <p id="progress-sub" class="text-xs text-slate-500 mt-1"></p>
          <div id="process-steps" class="mt-5 flex gap-2 flex-wrap justify-center">
            <span id="step-ocr" class="px-2 py-1 bg-slate-800 text-slate-500 text-[10px] rounded-full">1.OCR</span>
            <span id="step-detect" class="px-2 py-1 bg-slate-800 text-slate-500 text-[10px] rounded-full">2.æ¤œå‡º</span>
            <span id="step-inpaint" class="px-2 py-1 bg-slate-800 text-slate-500 text-[10px] rounded-full">3.ã‚¤ãƒ³ãƒšã‚¤ãƒ³ãƒˆ</span>
            <span id="step-export" class="px-2 py-1 bg-slate-800 text-slate-500 text-[10px] rounded-full">4.å‡ºåŠ›</span>
          </div>
          <button id="cancel-button" class="mt-5 px-5 py-2 text-sm text-slate-500 hover:text-white rounded-full hover:bg-white/10 transition-all">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        </div>
        <div id="editor-area" class="hidden space-y-4">
          <div class="flex flex-col md:flex-row gap-2 items-stretch md:items-center justify-between bg-white/5 border border-white/10 rounded-xl p-2.5">
            <div class="flex gap-2 items-center justify-center md:justify-start flex-wrap">
              <span id="file-name" class="text-sm text-cyan-300 font-medium truncate max-w-[100px]"></span>
              <span id="slide-count" class="text-xs text-slate-500"></span>
              <span class="text-xs text-slate-600">|</span>
              <span class="text-xs text-green-400"><span id="stat-blocks">0</span>B</span>
              <span class="text-xs text-blue-400"><span id="stat-graphics">0</span>G</span>
              <span id="processing-time" class="text-xs text-slate-500"></span>
              <span id="quality-badge" class="text-[9px] px-2 py-0.5 bg-cyan-500/20 text-cyan-300 rounded-full hidden"></span>
            </div>
            <div class="flex gap-1.5 flex-wrap justify-center">
              <button id="download-clean-pptx-btn" class="flex-1 md:flex-none px-3 py-2 bg-gradient-to-r from-green-500 to-emerald-600 hover:from-green-600 hover:to-emerald-700 text-white rounded-lg text-xs font-medium transition-all flex items-center justify-center gap-1 shadow-lg touch-feedback"><i data-lucide="file-check" class="w-3.5 h-3.5"></i><span>ã‚¯ãƒªãƒ¼ãƒ³PPTX</span></button>
              <button id="download-zip-btn" class="px-2.5 py-2 bg-cyan-600 hover:bg-cyan-700 text-white rounded-lg text-xs font-medium transition-all touch-feedback" title="ZIP"><i data-lucide="file-archive" class="w-3.5 h-3.5"></i></button>
              <button id="download-json-btn" class="px-2.5 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-xs font-medium transition-all touch-feedback" title="JSON"><i data-lucide="file-json" class="w-3.5 h-3.5"></i></button>
              <button id="reset-btn" class="px-2.5 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg text-xs font-medium transition-all touch-feedback" title="ãƒªã‚»ãƒƒãƒˆ"><i data-lucide="refresh-cw" class="w-3.5 h-3.5"></i></button>
            </div>
          </div>
          <div class="flex gap-1.5 overflow-x-auto">
            <button id="tab-compare" class="tab-btn tab-active px-3 py-1.5 rounded-lg border border-white/10 text-xs font-medium flex items-center gap-1.5"><i data-lucide="columns" class="w-3.5 h-3.5"></i>æ¯”è¼ƒ</button>
            <button id="tab-blocks" class="tab-btn px-3 py-1.5 rounded-lg border border-white/10 text-xs font-medium flex items-center gap-1.5 text-slate-400"><i data-lucide="list" class="w-3.5 h-3.5"></i>ãƒ†ã‚­ã‚¹ãƒˆ</button>
            <button id="tab-graphics" class="tab-btn px-3 py-1.5 rounded-lg border border-white/10 text-xs font-medium flex items-center gap-1.5 text-slate-400"><i data-lucide="image" class="w-3.5 h-3.5"></i>å›³å½¢</button>
          </div>
          <div id="tab-content-compare" class="tab-content">
            <div class="bg-white/5 border border-white/10 rounded-xl p-3">
              <div class="flex items-center justify-between mb-3"><h3 class="text-sm font-bold text-white">å…ƒç”»åƒ vs ã‚¤ãƒ³ãƒšã‚¤ãƒ³ãƒˆæ¸ˆ</h3><div class="flex items-center gap-1.5"><button id="prev-compare" class="p-1.5 bg-slate-800 hover:bg-slate-700 rounded-lg"><i data-lucide="chevron-left" class="w-4 h-4"></i></button><span id="compare-index" class="text-xs text-slate-400 min-w-[40px] text-center">1/1</span><button id="next-compare" class="p-1.5 bg-slate-800 hover:bg-slate-700 rounded-lg"><i data-lucide="chevron-right" class="w-4 h-4"></i></button></div></div>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-3"><div><p class="text-xs text-slate-500 mb-1.5 text-center">å…ƒç”»åƒ</p><div id="original-preview" class="bg-black/30 rounded-lg overflow-hidden"></div></div><div><p class="text-xs text-slate-500 mb-1.5 text-center">ãƒ†ã‚­ã‚¹ãƒˆæ¶ˆå»å¾Œ</p><div id="erased-preview" class="bg-black/30 rounded-lg overflow-hidden"></div></div></div>
            </div>
          </div>
          <div id="tab-content-blocks" class="tab-content hidden">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-3"><div class="bg-white/5 border border-white/10 rounded-xl p-3 max-h-[55vh] overflow-y-auto custom-scrollbar"><h3 class="text-xs font-bold text-white mb-2">ã‚¹ãƒ©ã‚¤ãƒ‰</h3><div id="block-slide-list" class="space-y-1.5"></div></div><div class="lg:col-span-2 bg-white/5 border border-white/10 rounded-xl p-3 max-h-[55vh] overflow-y-auto custom-scrollbar"><h3 class="text-xs font-bold text-white mb-2">ãƒ†ã‚­ã‚¹ãƒˆ <span id="block-count" class="text-slate-400"></span></h3><div id="block-list" class="space-y-1.5"></div></div></div>
          </div>
          <div id="tab-content-graphics" class="tab-content hidden">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-3"><div class="bg-white/5 border border-white/10 rounded-xl p-3 max-h-[55vh] overflow-y-auto custom-scrollbar"><h3 class="text-xs font-bold text-white mb-2">ã‚¹ãƒ©ã‚¤ãƒ‰</h3><div id="graphics-slide-list" class="space-y-1.5"></div></div><div class="lg:col-span-2 bg-white/5 border border-white/10 rounded-xl p-3 max-h-[55vh] overflow-y-auto custom-scrollbar"><h3 class="text-xs font-bold text-white mb-2">å›³å½¢ <span id="graphics-count" class="text-slate-400"></span></h3><div id="graphics-list" class="grid grid-cols-2 sm:grid-cols-3 gap-2"></div></div></div>
          </div>
        </div>
        <div id="error-area" class="hidden bg-white/5 rounded-2xl border border-white/10 p-10 text-center space-y-3"><div class="w-12 h-12 bg-red-500/20 rounded-full flex items-center justify-center mx-auto"><i data-lucide="x" class="w-6 h-6 text-red-500"></i></div><h3 class="text-base font-bold text-slate-200">ã‚¨ãƒ©ãƒ¼</h3><p id="error-message" class="text-slate-500 text-sm"></p><button id="retry-btn" class="px-5 py-2 bg-white/10 text-white rounded-xl hover:bg-white/20 transition-all text-sm">ãƒªãƒˆãƒ©ã‚¤</button></div>
      </main>
      <footer class="text-center text-xs text-slate-600 py-3">PDF Slide Studio Pro v7.2</footer>
    </div>
  </div>
  <div id="toast" class="fixed bottom-5 left-1/2 -translate-x-1/2 z-50 hidden px-4 py-2 bg-slate-800 border border-slate-700 text-white rounded-xl shadow-xl"><div class="flex items-center gap-2"><i id="toast-icon" data-lucide="check-circle" class="w-4 h-4 text-green-400"></i><span id="toast-message" class="text-sm">å®Œäº†</span></div></div>
  <script>
    'use strict';
    const CONFIG = Object.freeze({CANVAS_SCALE:2.5,MAX_GRAPHICS:25,MIN_GRAPHIC_SIZE:40,EDGE_THRESHOLD:35,COLOR_QUANTIZE:6,PROGRESS_CIRCUMFERENCE:289,FLOOD_FILL_MAX:50000,MAX_FILE_SIZE:100*1024*1024,TEXT_BRIGHTNESS_THRESHOLD:200,PARAGRAPH_MERGE_THRESHOLD:24,LINE_OVERLAP_RATIO:0.30});
    const QUALITY = {fast:{scale:2.0,passes:1},balanced:{scale:2.5,passes:3},quality:{scale:3.0,passes:5}};
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    const state = {file:null,images:[],zipBlob:null,cancelRequested:false,isExporting:false,currentCompareIndex:0,selectedSlideIndex:null,selectedGraphicsSlideIndex:null,startTime:0,ocrLanguage:'jpn+eng',minConfidence:40,inpaintStrength:8,blendRadius:12,multiPass:true,shapeProtection:60,detectGraphics:true,fixBrokenText:true,fontFamily:'Meiryo',autoBold:true,detectTextColor:true,qualityMode:'balanced',smoothEdges:true};
    const el = {};
    const escapeHtml = s => s ? s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]) : '';
    const rgbToHex = (r, g, b) => ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
    const formatTime = ms => ms < 1000 ? `${ms|0}ms` : `${(ms/1000).toFixed(1)}ç§’`;
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const formatFileSize = b => b < 1024*1024 ? `${(b/1024).toFixed(1)}KB` : `${(b/1024/1024).toFixed(1)}MB`;
    const createMask = (w, h) => new Uint8Array(w * h);
    function setMaskRect(mask, w, x0, y0, x1, y1) { for (let y = y0; y < y1; y++) { const row = y * w; for (let x = x0; x < x1; x++) mask[row + x] = 1; } }
    function toGrayscale(data, len) { const g = new Uint8Array(len); for (let i = 0, j = 0; i < data.length; i += 4, j++) g[j] = (data[i] * 77 + data[i+1] * 150 + data[i+2] * 29) >> 8; return g; }
    function detectEdges(gray, w, h) { const edges = new Uint8Array(w * h); for (let y = 1; y < h - 1; y++) { const row = y * w, rowP = row - w, rowN = row + w; for (let x = 1; x < w - 1; x++) { const gx = -gray[rowP+x-1] + gray[rowP+x+1] - (gray[row+x-1]<<1) + (gray[row+x+1]<<1) - gray[rowN+x-1] + gray[rowN+x+1]; const gy = -gray[rowP+x-1] - (gray[rowP+x]<<1) - gray[rowP+x+1] + gray[rowN+x-1] + (gray[rowN+x]<<1) + gray[rowN+x+1]; edges[row+x] = Math.min(255, Math.sqrt(gx*gx + gy*gy)|0); } } return edges; }
    
    // v7.2: ãƒãƒ«ãƒãƒ‘ã‚¹ã‚¤ãƒ³ãƒšã‚¤ãƒ³ãƒ†ã‚£ãƒ³ã‚°
    function advancedInpaint(data, w, h, mask, passes, blendRadius) {
      for (let pass = 0; pass < passes; pass++) {
        const radius = blendRadius + pass * 2;
        for (let y = 1; y < h - 1; y++) {
          for (let x = 1; x < w - 1; x++) {
            const idx = y * w + x;
            if (!mask[idx]) continue;
            let sumR = 0, sumG = 0, sumB = 0, totalWeight = 0;
            for (let dy = -radius; dy <= radius; dy++) {
              for (let dx = -radius; dx <= radius; dx++) {
                const ny = y + dy, nx = x + dx;
                if (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;
                const nIdx = ny * w + nx;
                if (mask[nIdx]) continue;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > radius) continue;
                const weight = 1 / (1 + dist * 0.3);
                const pIdx = nIdx << 2;
                sumR += data[pIdx] * weight;
                sumG += data[pIdx+1] * weight;
                sumB += data[pIdx+2] * weight;
                totalWeight += weight;
              }
            }
            if (totalWeight > 0) {
              const pIdx = idx << 2;
              data[pIdx] = (sumR / totalWeight)|0;
              data[pIdx+1] = (sumG / totalWeight)|0;
              data[pIdx+2] = (sumB / totalWeight)|0;
            }
          }
        }
        if (pass === passes - 1 && state.smoothEdges) smoothMaskEdges(data, w, h, mask, Math.min(radius, 6));
      }
    }
    
    function smoothMaskEdges(data, w, h, mask, radius) {
      const edgeMask = createMask(w, h);
      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const idx = y * w + x;
          if (!mask[idx]) continue;
          outer: for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nIdx = (y + dy) * w + (x + dx);
              if (!mask[nIdx]) { edgeMask[idx] = 1; break outer; }
            }
          }
        }
      }
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = y * w + x;
          if (!edgeMask[idx]) continue;
          let sumR = 0, sumG = 0, sumB = 0, count = 0;
          for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
              const ny = y + dy, nx = x + dx;
              if (ny < 0 || ny >= h || nx < 0 || nx >= w) continue;
              const weight = 1 / (1 + Math.sqrt(dx*dx + dy*dy) * 0.5);
              const pIdx = (ny * w + nx) << 2;
              sumR += data[pIdx] * weight; sumG += data[pIdx+1] * weight; sumB += data[pIdx+2] * weight;
              count += weight;
            }
          }
          if (count > 0) { const pIdx = idx << 2; data[pIdx] = (sumR / count)|0; data[pIdx+1] = (sumG / count)|0; data[pIdx+2] = (sumB / count)|0; }
        }
      }
    }
    
    function detectGraphics(data, gray, edges, w, h, textBlocks) {
      const textMask = createMask(w, h);
      const margin = 12;
      for (const block of textBlocks) {
        if (!block.bbox) continue;
        const x0 = clamp(Math.floor(block.bbox.x0) - margin, 0, w);
        const y0 = clamp(Math.floor(block.bbox.y0) - margin, 0, h);
        const x1 = clamp(Math.ceil(block.bbox.x1) + margin, 0, w);
        const y1 = clamp(Math.ceil(block.bbox.y1) + margin, 0, h);
        setMaskRect(textMask, w, x0, y0, x1, y1);
      }
      const visited = createMask(w, h);
      const graphics = [];
      const threshold = CONFIG.EDGE_THRESHOLD;
      const minArea = 500, maxArea = w * h * 0.4;
      const stackX = new Int32Array(CONFIG.FLOOD_FILL_MAX);
      const stackY = new Int32Array(CONFIG.FLOOD_FILL_MAX);
      function floodFill(startX, startY) {
        let sp = 0; stackX[sp] = startX; stackY[sp] = startY; sp++;
        let minX = startX, maxX = startX, minY = startY, maxY = startY;
        let colorR = 0, colorG = 0, colorB = 0, count = 0;
        while (sp > 0 && count < CONFIG.FLOOD_FILL_MAX) {
          sp--; const x = stackX[sp], y = stackY[sp];
          if (x < 0 || x >= w || y < 0 || y >= h) continue;
          const idx = y * w + x;
          if (visited[idx] || textMask[idx]) continue;
          if (edges[idx] < threshold && count > 0) continue;
          visited[idx] = 1; count++;
          const pIdx = idx << 2;
          colorR += data[pIdx]; colorG += data[pIdx+1]; colorB += data[pIdx+2];
          if (x < minX) minX = x; if (x > maxX) maxX = x;
          if (y < minY) minY = y; if (y > maxY) maxY = y;
          if (sp < CONFIG.FLOOD_FILL_MAX - 4) {
            stackX[sp] = x+1; stackY[sp] = y; sp++;
            stackX[sp] = x-1; stackY[sp] = y; sp++;
            stackX[sp] = x; stackY[sp] = y+1; sp++;
            stackX[sp] = x; stackY[sp] = y-1; sp++;
          }
        }
        return { minX, maxX, minY, maxY, count, colorR, colorG, colorB };
      }
      for (let y = 20; y < h - 20; y += 30) {
        for (let x = 20; x < w - 20; x += 30) {
          const idx = y * w + x;
          if (visited[idx] || textMask[idx] || edges[idx] < threshold) continue;
          const r = floodFill(x, y);
          if (r.count < minArea || r.count > maxArea) continue;
          const gw = r.maxX - r.minX, gh = r.maxY - r.minY;
          if (gw < CONFIG.MIN_GRAPHIC_SIZE || gh < CONFIG.MIN_GRAPHIC_SIZE) continue;
          const avgR = (r.colorR / r.count)|0, avgG = (r.colorG / r.count)|0, avgB = (r.colorB / r.count)|0;
          let variance = 0, sc = 0;
          const step = Math.max(3, Math.floor(Math.sqrt(r.count / 50)));
          for (let sy = r.minY; sy <= r.maxY && sc < 50; sy += step) {
            for (let sx = r.minX; sx <= r.maxX && sc < 50; sx += step) {
              const sIdx = (sy * w + sx) << 2;
              variance += Math.abs(data[sIdx] - avgR) + Math.abs(data[sIdx+1] - avgG) + Math.abs(data[sIdx+2] - avgB);
              sc++;
            }
          }
          variance = sc > 0 ? variance / sc : 0;
          const isPhoto = variance > 40;
          const fillRatio = r.count / (gw * gh);
          graphics.push({id: graphics.length, type: isPhoto ? 'photo' : (fillRatio > 0.6 ? 'filled' : 'outline'), x: r.minX, y: r.minY, width: gw, height: gh, area: r.count, isPhoto, colorHex: rgbToHex(avgR, avgG, avgB)});
        }
      }
      graphics.sort((a, b) => b.area - a.area);
      return graphics.slice(0, CONFIG.MAX_GRAPHICS);
    }
    
    function eraseTextWithInpaint(data, edges, w, h, blocks, graphics) {
      const eraseMask = createMask(w, h);
      const protectedMask = createMask(w, h);
      for (const g of graphics) {
        const m = g.isPhoto ? 25 : 10;
        const x0 = clamp(g.x - m, 0, w), y0 = clamp(g.y - m, 0, h);
        const x1 = clamp(g.x + g.width + m, 0, w), y1 = clamp(g.y + g.height + m, 0, h);
        setMaskRect(protectedMask, w, x0, y0, x1, y1);
      }
      const protThreshold = (state.shapeProtection / 100) * 255;
      const strength = state.inpaintStrength;
      for (const block of blocks) {
        if (!block.bbox) continue;
        const bx0 = clamp(Math.floor(block.bbox.x0) - strength, 0, w);
        const by0 = clamp(Math.floor(block.bbox.y0) - strength, 0, h);
        const bx1 = clamp(Math.ceil(block.bbox.x1) + strength, 0, w);
        const by1 = clamp(Math.ceil(block.bbox.y1) + strength, 0, h);
        for (let y = by0; y < by1; y++) {
          const row = y * w;
          for (let x = bx0; x < bx1; x++) {
            const idx = row + x;
            if (protectedMask[idx]) continue;
            if (edges[idx] > protThreshold) {
              let ns = 0;
              for (let dy = -1; dy <= 1; dy++) { for (let dx = -1; dx <= 1; dx++) { const ni = (y+dy)*w + (x+dx); if (ni >= 0 && ni < edges.length) ns += edges[ni]; } }
              if (ns > protThreshold * 5) continue;
            }
            eraseMask[idx] = 1;
          }
        }
      }
      const passes = state.multiPass ? QUALITY[state.qualityMode].passes : 1;
      advancedInpaint(data, w, h, eraseMask, passes, state.blendRadius);
      return eraseMask;
    }
    
    function detectTextColor(data, w, h, bbox) {
      if (!bbox) return '333333';
      const x0 = clamp(Math.floor(bbox.x0), 0, w), y0 = clamp(Math.floor(bbox.y0), 0, h);
      const x1 = clamp(Math.ceil(bbox.x1), 0, w), y1 = clamp(Math.ceil(bbox.y1), 0, h);
      const darkColors = new Map();
      for (let y = y0; y < y1; y += 2) {
        for (let x = x0; x < x1; x += 2) {
          const idx = (y * w + x) << 2;
          const r = data[idx], g = data[idx+1], b = data[idx+2];
          const brightness = (r + g + b) / 3;
          if (brightness < CONFIG.TEXT_BRIGHTNESS_THRESHOLD) {
            const qr = (r/24|0)*24, qg = (g/24|0)*24, qb = (b/24|0)*24;
            const key = (qr << 16) | (qg << 8) | qb;
            const e = darkColors.get(key);
            if (e) { e.count++; e.r += r; e.g += g; e.b += b; }
            else darkColors.set(key, { count: 1, r, g, b });
          }
        }
      }
      if (darkColors.size === 0) return '333333';
      let maxCount = 0, dom = { r: 51, g: 51, b: 51 };
      for (const v of darkColors.values()) { if (v.count > maxCount) { maxCount = v.count; dom = { r: (v.r/v.count)|0, g: (v.g/v.count)|0, b: (v.b/v.count)|0 }; } }
      return rgbToHex(dom.r, dom.g, dom.b);
    }
    
    function mergeTextLines(lines, w, h, imageData) {
      if (!lines || lines.length === 0) return [];
      const minConf = state.minConfidence;
      const filtered = lines.filter(l => {
        if (!l.text || !l.bbox || l.confidence < minConf) return false;
        const t = l.text.trim();
        if (t.length < 2) return false;
        if (/^[\s\-_=|\\\/\[\]{}()"'`~!@#$%^&*.,;:]+$/.test(t)) return false;
        return true;
      });
      if (filtered.length === 0) return [];
      filtered.sort((a, b) => a.bbox.y0 - b.bbox.y0);
      const lineGroups = [];
      let cg = null;
      for (const line of filtered) {
        if (!cg) { cg = { lines: [line], y0: line.bbox.y0, y1: line.bbox.y1, x0: line.bbox.x0, x1: line.bbox.x1 }; }
        else {
          const overlap = Math.min(cg.y1, line.bbox.y1) - Math.max(cg.y0, line.bbox.y0);
          const lh = Math.min(cg.y1 - cg.y0, line.bbox.y1 - line.bbox.y0);
          if (overlap > lh * CONFIG.LINE_OVERLAP_RATIO) {
            cg.lines.push(line);
            cg.x0 = Math.min(cg.x0, line.bbox.x0); cg.x1 = Math.max(cg.x1, line.bbox.x1);
            cg.y0 = Math.min(cg.y0, line.bbox.y0); cg.y1 = Math.max(cg.y1, line.bbox.y1);
          } else { lineGroups.push(cg); cg = { lines: [line], y0: line.bbox.y0, y1: line.bbox.y1, x0: line.bbox.x0, x1: line.bbox.x1 }; }
        }
      }
      if (cg) lineGroups.push(cg);
      for (const g of lineGroups) {
        g.lines.sort((a, b) => a.bbox.x0 - b.bbox.x0);
        g.text = g.lines.map(l => l.text.trim()).join(' ');
        g.confidence = Math.round(g.lines.reduce((s, l) => s + l.confidence, 0) / g.lines.length);
      }
      const paragraphs = [];
      let cp = null;
      for (const g of lineGroups) {
        if (!cp) { cp = { lines: [g], text: g.text, bbox: { x0: g.x0, y0: g.y0, x1: g.x1, y1: g.y1 }, confidence: g.confidence }; }
        else {
          const gap = g.y0 - cp.bbox.y1;
          const xOverlap = Math.min(cp.bbox.x1, g.x1) - Math.max(cp.bbox.x0, g.x0);
          const minWidth = Math.min(cp.bbox.x1 - cp.bbox.x0, g.x1 - g.x0);
          const ratio = minWidth > 0 ? xOverlap / minWidth : 0;
          if (gap >= -5 && gap < CONFIG.PARAGRAPH_MERGE_THRESHOLD && ratio > 0.12) {
            cp.lines.push(g); cp.text += '\n' + g.text;
            cp.bbox.x0 = Math.min(cp.bbox.x0, g.x0); cp.bbox.x1 = Math.max(cp.bbox.x1, g.x1);
            cp.bbox.y1 = g.y1;
            cp.confidence = Math.round((cp.confidence + g.confidence) / 2);
          } else { paragraphs.push(cp); cp = { lines: [g], text: g.text, bbox: { x0: g.x0, y0: g.y0, x1: g.x1, y1: g.y1 }, confidence: g.confidence }; }
        }
      }
      if (cp) paragraphs.push(cp);
      const data = imageData ? imageData.data : null;
      return paragraphs.map((p, idx) => {
        const height = p.bbox.y1 - p.bbox.y0;
        const lc = p.lines.length;
        const lh = height / lc;
        const hasJp = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FFF]/.test(p.text);
        const coeff = hasJp ? 0.55 : 0.65;
        return { id: idx, text: p.text, confidence: p.confidence, bbox: p.bbox, lineCount: lc, fontSize: clamp(Math.round(lh * coeff), 8, 48), textColor: (state.detectTextColor && data) ? detectTextColor(data, w, h, p.bbox) : '333333' };
      });
    }
    
    function repairBrokenText(blocks) {
      if (!state.fixBrokenText) return blocks;
      return blocks.map(block => {
        let text = block.text;
        text = text.replace(/[oO](?=\d|\d(?=[oO]))/g, '0');
        text = text.replace(/[lI|](?=\d)/g, '1');
        text = text.replace(/\s{2,}/g, ' ');
        text = text.replace(/\n{3,}/g, '\n\n');
        return { ...block, text: text.trim(), repaired: text !== block.text };
      });
    }
    
    async function performOCR(imageDataUrl, language) {
      if (!window.Tesseract) return { text: '', confidence: 0, lines: [] };
      try {
        if (state.cancelRequested) throw new Error('Cancelled');
        const worker = await Tesseract.createWorker(language, 1, {
          logger: m => { if (m.status === 'recognizing text' && el.progressSub) el.progressSub.textContent = `OCR: ${Math.round(m.progress * 100)}%`; }
        });
        const result = await worker.recognize(imageDataUrl);
        await worker.terminate();
        return { text: result.data.text.trim(), confidence: Math.round(result.data.confidence), lines: result.data.lines || [] };
      } catch (err) {
        if (err.message === 'Cancelled') throw err;
        console.warn('OCRã‚¨ãƒ©ãƒ¼:', err.message);
        return { text: '', confidence: 0, lines: [] };
      }
    }
    
    function readSettings() {
      state.ocrLanguage = el.ocrLanguage.value;
      state.minConfidence = +el.minConfidence.value;
      state.inpaintStrength = +el.inpaintStrength.value;
      state.blendRadius = +el.blendRadius.value;
      state.multiPass = el.multiPass.checked;
      state.shapeProtection = +el.shapeProtection.value;
      state.detectGraphics = el.detectGraphics.checked;
      state.fixBrokenText = el.fixBrokenText.checked;
      state.fontFamily = el.fontFamily.value;
      state.autoBold = el.autoBold.checked;
      state.detectTextColor = el.detectTextColor.checked;
      state.qualityMode = el.qualityMode.value;
      state.smoothEdges = el.smoothEdges.checked;
    }
    
    function validateFile(file) {
      if (!file) return { valid: false, error: 'ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“' };
      if (file.type !== 'application/pdf') return { valid: false, error: 'PDFãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿å¯¾å¿œ' };
      if (file.size > CONFIG.MAX_FILE_SIZE) return { valid: false, error: 'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã¾ã™' };
      return { valid: true };
    }
    
    function updateStep(step) {
      ['ocr', 'detect', 'inpaint', 'export'].forEach((s, i) => {
        const e = document.getElementById(`step-${s}`);
        if (!e) return;
        if (s === step) e.className = 'px-2 py-1 bg-cyan-500 text-white text-[10px] rounded-full animate-pulse';
        else if (['ocr', 'detect', 'inpaint', 'export'].indexOf(step) > i) e.className = 'px-2 py-1 bg-green-500/30 text-green-300 text-[10px] rounded-full';
        else e.className = 'px-2 py-1 bg-slate-800 text-slate-500 text-[10px] rounded-full';
      });
    }
    
    async function processFile(file) {
      const v = validateFile(file);
      if (!v.valid) { showError(v.error); return; }
      state.file = file; state.images = []; state.zipBlob = null; state.cancelRequested = false; state.currentCompareIndex = 0; state.startTime = performance.now();
      const q = QUALITY[state.qualityMode];
      showProcessing();
      updateProgress(0, 0, 'PDFè§£æä¸­...', `${formatFileSize(file.size)} / ${state.qualityMode}`, '');
      try {
        const arrayBuffer = await file.arrayBuffer();
        let pdf;
        try { pdf = await pdfjsLib.getDocument(arrayBuffer).promise; } catch (e) { throw new Error('PDFã‚’èª­ã¿è¾¼ã‚ã¾ã›ã‚“ã§ã—ãŸ'); }
        const total = pdf.numPages;
        const zip = new JSZip();
        for (let i = 1; i <= total; i++) {
          if (state.cancelRequested) { reset(); showToast('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ', 'info'); return; }
          updateStep('ocr');
          updateProgress(i, total, `ã‚¹ãƒ©ã‚¤ãƒ‰ ${i}/${total}`, 'OCRå‡¦ç†...', '');
          const page = await pdf.getPage(i);
          const viewport = page.getViewport({ scale: q.scale });
          const w = viewport.width, h = viewport.height;
          const canvas = document.createElement('canvas');
          canvas.width = w; canvas.height = h;
          const ctx = canvas.getContext('2d');
          await page.render({ canvasContext: ctx, viewport }).promise;
          const originalDataUrl = canvas.toDataURL('image/png');
          const imageData = ctx.getImageData(0, 0, w, h);
          const data = imageData.data;
          const gray = toGrayscale(data, w * h);
          const edges = detectEdges(gray, w, h);
          const ocrResult = await performOCR(originalDataUrl, state.ocrLanguage);
          if (state.cancelRequested) { reset(); showToast('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ', 'info'); return; }
          let blocks = mergeTextLines(ocrResult.lines, w, h, imageData);
          blocks = repairBrokenText(blocks);
          updateStep('detect');
          updateProgress(i, total, `ã‚¹ãƒ©ã‚¤ãƒ‰ ${i}/${total}`, 'å›³å½¢æ¤œå‡º...', '');
          let graphics = [];
          if (state.detectGraphics) graphics = detectGraphics(data, gray, edges, w, h, blocks);
          updateStep('inpaint');
          updateProgress(i, total, `ã‚¹ãƒ©ã‚¤ãƒ‰ ${i}/${total}`, 'ã‚¤ãƒ³ãƒšã‚¤ãƒ³ãƒ†ã‚£ãƒ³ã‚°...', '');
          const erasedCanvas = document.createElement('canvas');
          erasedCanvas.width = w; erasedCanvas.height = h;
          const erasedCtx = erasedCanvas.getContext('2d');
          erasedCtx.drawImage(canvas, 0, 0);
          const erasedImageData = erasedCtx.getImageData(0, 0, w, h);
          eraseTextWithInpaint(erasedImageData.data, edges, w, h, blocks, graphics);
          erasedCtx.putImageData(erasedImageData, 0, 0);
          const erasedDataUrl = erasedCanvas.toDataURL('image/png');
          const erasedBlob = await new Promise(r => erasedCanvas.toBlob(r, 'image/png'));
          const graphicImages = [];
          for (const g of graphics) {
            if (g.width < CONFIG.MIN_GRAPHIC_SIZE || g.height < CONFIG.MIN_GRAPHIC_SIZE) continue;
            const gc = document.createElement('canvas');
            gc.width = g.width; gc.height = g.height;
            gc.getContext('2d').drawImage(canvas, g.x, g.y, g.width, g.height, 0, 0, g.width, g.height);
            graphicImages.push({ ...g, dataUrl: gc.toDataURL('image/png') });
            gc.width = 0; gc.height = 0;
          }
          state.images.push({ id: i, originalDataUrl, erasedDataUrl, erasedBlob, width: w, height: h, blocks, graphics: graphicImages, text: ocrResult.text });
          zip.file(`slide_${String(i).padStart(2, '0')}_clean.png`, erasedBlob);
          canvas.width = 0; canvas.height = 0;
          erasedCanvas.width = 0; erasedCanvas.height = 0;
          await new Promise(r => setTimeout(r, 10));
        }
        if (state.cancelRequested) { reset(); showToast('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ', 'info'); return; }
        updateStep('export');
        updateProgress(total, total, 'ZIPä½œæˆ...', '', '');
        state.zipBlob = await zip.generateAsync({ type: 'blob' });
        const elapsed = performance.now() - state.startTime;
        showEditor(elapsed);
        showToast(`${total}æšå‡¦ç†å®Œäº†ï¼ˆ${formatTime(elapsed)}ï¼‰`, 'success');
      } catch (err) {
        if (err.message === 'Cancelled') { reset(); showToast('ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ', 'info'); }
        else { console.warn('å‡¦ç†ã‚¨ãƒ©ãƒ¼:', err); showError(err.message || 'äºˆæœŸã›ã¬ã‚¨ãƒ©ãƒ¼'); }
      }
    }
    
    function showProcessing() { el.uploadArea.classList.add('hidden'); el.processingArea.classList.remove('hidden'); el.processingArea.style.display = 'flex'; el.editorArea.classList.add('hidden'); el.errorArea.classList.add('hidden'); el.headerContent.classList.add('hidden'); }
    function showEditor(ms) {
      el.uploadArea.classList.add('hidden'); el.processingArea.classList.add('hidden'); el.processingArea.style.display = 'none'; el.editorArea.classList.remove('hidden'); el.errorArea.classList.add('hidden'); el.headerContent.classList.add('hidden');
      el.fileName.textContent = state.file.name;
      el.slideCount.textContent = `${state.images.length}æš`;
      el.statBlocks.textContent = state.images.reduce((s, i) => s + (i.blocks?.length || 0), 0);
      el.statGraphics.textContent = state.images.reduce((s, i) => s + (i.graphics?.length || 0), 0);
      if (ms) el.processingTime.textContent = `(${formatTime(ms)})`;
      el.qualityBadge.textContent = { fast: 'é«˜é€Ÿ', balanced: 'ãƒãƒ©ãƒ³ã‚¹', quality: 'é«˜å“è³ª' }[state.qualityMode];
      el.qualityBadge.classList.remove('hidden');
      updateCompareView(); renderBlockSlideList(); renderGraphicsSlideList();
    }
    function showError(msg) { el.uploadArea.classList.add('hidden'); el.processingArea.classList.add('hidden'); el.editorArea.classList.add('hidden'); el.errorArea.classList.remove('hidden'); el.headerContent.classList.remove('hidden'); el.errorMessage.textContent = msg; }
    function reset() {
      state.file = null; state.images = []; state.zipBlob = null; state.cancelRequested = false; state.currentCompareIndex = 0; state.selectedSlideIndex = null; state.selectedGraphicsSlideIndex = null; el.fileInput.value = '';
      el.uploadArea.classList.remove('hidden'); el.processingArea.classList.add('hidden'); el.processingArea.style.display = 'none'; el.editorArea.classList.add('hidden'); el.errorArea.classList.add('hidden'); el.headerContent.classList.remove('hidden'); switchTab('compare');
    }
    function updateProgress(cur, tot, msg, detail, sub) {
      const pct = tot > 0 ? Math.round((cur / tot) * 100) : 0;
      el.progressCircle.setAttribute('stroke-dasharray', `${CONFIG.PROGRESS_CIRCUMFERENCE * pct / 100} ${CONFIG.PROGRESS_CIRCUMFERENCE}`);
      el.progressPercent.textContent = `${pct}%`; el.progressMessage.textContent = msg; el.progressDetail.textContent = detail; el.progressSub.textContent = sub || '';
    }
    function switchTab(name) {
      document.querySelectorAll('.tab-btn').forEach(b => { const active = b.id === `tab-${name}`; b.classList.toggle('tab-active', active); b.classList.toggle('text-slate-400', !active); });
      document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
      const content = document.getElementById(`tab-content-${name}`); if (content) content.classList.remove('hidden');
    }
    function updateCompareView() {
      if (state.images.length === 0) return;
      const img = state.images[state.currentCompareIndex];
      el.compareIndex.textContent = `${state.currentCompareIndex + 1}/${state.images.length}`;
      el.originalPreview.innerHTML = `<img src="${img.originalDataUrl}" class="w-full h-auto" alt="å…ƒç”»åƒ" loading="lazy">`;
      el.erasedPreview.innerHTML = `<img src="${img.erasedDataUrl}" class="w-full h-auto" alt="æ¶ˆå»å¾Œ" loading="lazy">`;
    }
    function navigateCompare(dir) { const idx = state.currentCompareIndex + dir; if (idx >= 0 && idx < state.images.length) { state.currentCompareIndex = idx; updateCompareView(); } }
    function renderBlockSlideList() {
      el.blockSlideList.innerHTML = '';
      state.images.forEach((img, idx) => {
        const btn = document.createElement('button');
        btn.className = `w-full p-2 rounded-lg text-left text-xs transition-all ${state.selectedSlideIndex === idx ? 'bg-cyan-600 text-white' : 'bg-slate-800/50 text-slate-300 hover:bg-slate-700'}`;
        btn.innerHTML = `<div class="flex justify-between"><span>ã‚¹ãƒ©ã‚¤ãƒ‰ ${idx+1}</span><span class="opacity-70">${img.blocks?.length||0}B</span></div>`;
        btn.onclick = () => selectBlockSlide(idx);
        el.blockSlideList.appendChild(btn);
      });
    }
    function selectBlockSlide(idx) {
      state.selectedSlideIndex = idx;
      const img = state.images[idx];
      el.blockCount.textContent = `(${img.blocks?.length||0})`;
      if (img.blocks && img.blocks.length > 0) {
        el.blockList.innerHTML = img.blocks.map((b, i) => `
          <div class="p-2 bg-slate-800/50 rounded-lg border-l-2 ${b.repaired ? 'border-yellow-500' : 'border-cyan-500'}">
            <div class="flex justify-between mb-1"><span class="text-xs font-bold text-cyan-300">B${i+1}${b.repaired ? ' ğŸ”§' : ''}</span><span class="text-xs text-slate-500">${b.confidence}% / ${b.fontSize}pt</span></div>
            <p class="text-xs text-slate-200 whitespace-pre-wrap">${escapeHtml(b.text)}</p>
            ${state.detectTextColor ? `<span class="inline-block w-3 h-3 rounded mt-1" style="background:#${b.textColor}"></span>` : ''}
          </div>`).join('');
      } else { el.blockList.innerHTML = '<p class="text-slate-500 text-xs">ãƒ–ãƒ­ãƒƒã‚¯ãªã—</p>'; }
      renderBlockSlideList();
    }
    function renderGraphicsSlideList() {
      el.graphicsSlideList.innerHTML = '';
      state.images.forEach((img, idx) => {
        const btn = document.createElement('button');
        btn.className = `w-full p-2 rounded-lg text-left text-xs transition-all ${state.selectedGraphicsSlideIndex === idx ? 'bg-cyan-600 text-white' : 'bg-slate-800/50 text-slate-300 hover:bg-slate-700'}`;
        btn.innerHTML = `<div class="flex justify-between"><span>ã‚¹ãƒ©ã‚¤ãƒ‰ ${idx+1}</span><span class="opacity-70">${img.graphics?.length||0}G</span></div>`;
        btn.onclick = () => selectGraphicsSlide(idx);
        el.graphicsSlideList.appendChild(btn);
      });
    }
    function selectGraphicsSlide(idx) {
      state.selectedGraphicsSlideIndex = idx;
      const img = state.images[idx];
      el.graphicsCount.textContent = `(${img.graphics?.length||0})`;
      if (img.graphics && img.graphics.length > 0) {
        el.graphicsList.innerHTML = img.graphics.map((g, i) => `<div class="bg-slate-800/50 rounded-lg overflow-hidden"><img src="${g.dataUrl}" class="w-full h-auto" alt="å›³å½¢${i+1}" loading="lazy"><div class="p-1.5 text-xs text-slate-400">${g.width}Ã—${g.height} / ${g.type}</div></div>`).join('');
      } else { el.graphicsList.innerHTML = '<p class="text-slate-500 text-xs col-span-full">å›³å½¢ãªã—</p>'; }
      renderGraphicsSlideList();
    }
    function showToast(msg, type = 'success') {
      el.toastMessage.textContent = msg;
      const icon = type === 'success' ? 'check-circle' : type === 'error' ? 'x-circle' : 'info';
      const color = type === 'success' ? 'text-green-400' : type === 'error' ? 'text-red-400' : 'text-blue-400';
      el.toastIcon.setAttribute('data-lucide', icon); el.toastIcon.className = `w-4 h-4 ${color}`;
      lucide.createIcons(); el.toast.classList.remove('hidden'); setTimeout(() => el.toast.classList.add('hidden'), 3000);
    }
    function downloadFile(blob, name) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = name; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
    function setButtonsDisabled(d) { state.isExporting = d; el.downloadCleanPptxBtn.disabled = d; el.downloadZipBtn.disabled = d; el.downloadJsonBtn.disabled = d; }
    async function downloadCleanPptx() {
      if (!state.images.length || state.isExporting) return;
      try {
        setButtonsDisabled(true); showToast('PPTXä½œæˆä¸­...', 'info');
        const pptx = new PptxGenJS();
        const sw = 10, sh = 5.625;
        pptx.defineLayout({ name: 'CUSTOM', width: sw, height: sh }); pptx.layout = 'CUSTOM';
        for (const img of state.images) {
          const slide = pptx.addSlide();
          slide.addImage({ data: img.erasedDataUrl, x: 0, y: 0, w: sw, h: sh });
          if (img.blocks) {
            for (const b of img.blocks) {
              if (!b.bbox || !b.text) continue;
              const x = (b.bbox.x0 / img.width) * sw;
              const y = (b.bbox.y0 / img.height) * sh;
              const w = ((b.bbox.x1 - b.bbox.x0) / img.width) * sw;
              const h = ((b.bbox.y1 - b.bbox.y0) / img.height) * sh;
              const fs = clamp(Math.round(b.fontSize * 0.55), 8, 32);
              slide.addText(b.text, { x: Math.max(0, x - 0.01), y: Math.max(0, y), w: Math.max(w + 0.02, 0.4), h: Math.max(h, 0.2), fontSize: fs, fontFace: state.fontFamily, color: b.textColor || '333333', bold: state.autoBold && fs > 12, valign: 'top', wrap: true });
            }
          }
          if (img.text) slide.addNotes(img.text);
        }
        await pptx.writeFile({ fileName: state.file.name.replace('.pdf', '') + '_v72_clean.pptx' });
        showToast('ã‚¯ãƒªãƒ¼ãƒ³PPTXå®Œæˆï¼', 'success');
      } catch (err) { console.warn('PPTXã‚¨ãƒ©ãƒ¼:', err); showToast('PPTXä½œæˆå¤±æ•—', 'error'); }
      finally { setButtonsDisabled(false); }
    }
    function downloadZip() { if (state.zipBlob && state.file) { downloadFile(state.zipBlob, state.file.name.replace('.pdf', '') + '_v72_clean.zip'); showToast('ZIPãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†', 'success'); } }
    function downloadJson() {
      if (!state.images.length) return;
      const data = { filename: state.file.name, processedAt: new Date().toISOString(), version: 'v7.2', settings: { inpaintStrength: state.inpaintStrength, blendRadius: state.blendRadius, multiPass: state.multiPass, qualityMode: state.qualityMode }, slides: state.images.map((img, idx) => ({ slideNumber: idx + 1, width: img.width, height: img.height, blocks: img.blocks || [], graphics: (img.graphics || []).map(g => ({ type: g.type, x: g.x, y: g.y, width: g.width, height: g.height })) })) };
      downloadFile(new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' }), state.file.name.replace('.pdf', '') + '_v72_data.json');
      showToast('JSONãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†', 'success');
    }
    function setupEvents() {
      el.minConfidence.addEventListener('input', e => { state.minConfidence = +e.target.value; el.minConfidenceValue.textContent = `${state.minConfidence}%`; });
      el.inpaintStrength.addEventListener('input', e => { state.inpaintStrength = +e.target.value; el.inpaintStrengthValue.textContent = state.inpaintStrength; });
      el.blendRadius.addEventListener('input', e => { state.blendRadius = +e.target.value; el.blendRadiusValue.textContent = state.blendRadius; });
      el.shapeProtection.addEventListener('input', e => { state.shapeProtection = +e.target.value; el.shapeProtectionValue.textContent = `${state.shapeProtection}%`; });
      el.uploadButton.addEventListener('click', e => { e.preventDefault(); el.fileInput.click(); });
      el.fileInput.addEventListener('change', e => { const f = e.target.files[0]; if (f) { readSettings(); processFile(f); } });
      el.uploadButton.addEventListener('dragover', e => { e.preventDefault(); el.uploadButton.classList.add('bg-indigo-500/10'); });
      el.uploadButton.addEventListener('dragleave', e => { e.preventDefault(); el.uploadButton.classList.remove('bg-indigo-500/10'); });
      el.uploadButton.addEventListener('drop', e => { e.preventDefault(); el.uploadButton.classList.remove('bg-indigo-500/10'); const f = e.dataTransfer.files[0]; if (f) { readSettings(); processFile(f); } });
      el.cancelButton.addEventListener('click', () => { state.cancelRequested = true; });
      el.resetBtn.addEventListener('click', reset);
      el.retryBtn.addEventListener('click', reset);
      el.downloadCleanPptxBtn.addEventListener('click', downloadCleanPptx);
      el.downloadZipBtn.addEventListener('click', downloadZip);
      el.downloadJsonBtn.addEventListener('click', downloadJson);
      el.prevCompare.addEventListener('click', () => navigateCompare(-1));
      el.nextCompare.addEventListener('click', () => navigateCompare(1));
      document.addEventListener('keydown', e => { if (el.editorArea.classList.contains('hidden')) return; if (e.key === 'ArrowLeft') navigateCompare(-1); if (e.key === 'ArrowRight') navigateCompare(1); });
      document.querySelectorAll('.tab-btn').forEach(b => { b.addEventListener('click', () => switchTab(b.id.replace('tab-', ''))); });
    }
    function init() {
      const ids = ['file-input','upload-area','upload-button','processing-area','editor-area','error-area','init-status','header-content','progress-circle','progress-percent','progress-message','progress-detail','progress-sub','cancel-button','file-name','slide-count','stat-blocks','stat-graphics','processing-time','quality-badge','download-clean-pptx-btn','download-zip-btn','download-json-btn','reset-btn','retry-btn','error-message','toast','toast-icon','toast-message','ocr-language','min-confidence','min-confidence-value','inpaint-strength','inpaint-strength-value','blend-radius','blend-radius-value','multi-pass','shape-protection','shape-protection-value','detect-graphics','fix-broken-text','font-family','auto-bold','detect-text-color','quality-mode','smooth-edges','tab-compare','tab-blocks','tab-graphics','tab-content-compare','tab-content-blocks','tab-content-graphics','original-preview','erased-preview','compare-index','prev-compare','next-compare','block-slide-list','block-list','block-count','graphics-slide-list','graphics-list','graphics-count'];
      ids.forEach(id => { el[id.replace(/-([a-z])/g, (_, c) => c.toUpperCase())] = document.getElementById(id); });
      setupEvents(); lucide.createIcons();
      if (window.Tesseract) { el.initStatus.innerHTML = '<i data-lucide="check-circle" class="w-3 h-3 text-green-400"></i><span>æº–å‚™å®Œäº†</span>'; lucide.createIcons(); setTimeout(() => el.initStatus.classList.add('hidden'), 1500); }
    }
    function safeInit() { if (typeof lucide !== 'undefined') init(); else setTimeout(safeInit, 100); }
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', safeInit); else safeInit();
  </script>
</body>
</html>
